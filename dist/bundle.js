/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/fft-js/index.js":
/*!**************************************!*\
  !*** ./node_modules/fft-js/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\nmodule.exports = __webpack_require__(/*! ./src/fft */ \"./node_modules/fft-js/src/fft.js\");\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./node_modules/fft-js/index.js?");

/***/ }),

/***/ "./node_modules/fft-js/src/fft.js":
/*!****************************************!*\
  !*** ./node_modules/fft-js/src/fft.js ***!
  \****************************************/
/***/ ((module) => {

eval("/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// Proper optimization would involve memoization of\n// the sin() and cos() calls... and to get high\n// performace would require transforming the recursive\n// calls into a loop and then loop unrolling. All of\n// this is best accomplished in C or assembly.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\n\n//-------------------------------------------------\n// Add two complex numbers\n//-------------------------------------------------\nvar complexAdd = function (a, b)\n{\n    return [a[0] + b[0], a[1] + b[1]];\n};\n\n//-------------------------------------------------\n// Subtract two complex numbers\n//-------------------------------------------------\nvar complexSubtract = function (a, b)\n{\n    return [a[0] - b[0], a[1] - b[1]];\n};\n\n//-------------------------------------------------\n// Multiply two complex numbers\n//\n// (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n//-------------------------------------------------\nvar complexMultiply = function (a, b) \n{\n    return [(a[0] * b[0] - a[1] * b[1]), \n            (a[0] * b[1] + a[1] * b[0])];\n};\n\n//-------------------------------------------------\n// By Eulers Formula:\n//\n// e^(i*x) = cos(x) + i*sin(x)\n//\n// and in DFT:\n// \n// x = -2*PI*(k/N)\n//-------------------------------------------------\nvar exponent = function (k, N) {\n    var x = -2 * Math.PI * (k / N);\n\n         // Real       , Imaginary\n    return [Math.cos(x), Math.sin(x)];\n};\n\n//-------------------------------------------------\n// Calculate FFT for vector where vector.length\n// is assumed to be a power of 2.\n//-------------------------------------------------\nvar fft = function (vector) {\n    var X = [],\n        N = vector.length;\n\n    // Base case is X = x + 0i since our input is assumed to be real only.\n    if (N == 1) return [[vector[0], 0]];\n\n    // Recurse: all even samples\n    var X_evens = fft(vector.filter(even)),\n\n    // Recurse: all odd samples\n        X_odds = fft(vector.filter(odd));\n\n    // Now, perform N/2 operations!\n    for (var k = 0; k < N / 2; k++)\n    {\n        // t is a complex number!\n        var t = X_evens[k],\n            e = complexMultiply(exponent(k, N), X_odds[k]);\n\n        X[k] =         complexAdd(t, e);\n        X[k + (N/2)] = complexSubtract(t, e); \n    }\n\n    function even(__, ix) {return ix % 2 == 0;}\n    function odd (__, ix) {return ix % 2 == 1;}\n\n    return X;\n};\n\nmodule.exports = fft;\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./node_modules/fft-js/src/fft.js?");

/***/ }),

/***/ "./src/Controller.js":
/*!***************************!*\
  !*** ./src/Controller.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller)\n/* harmony export */ });\n/* harmony import */ var _SignalGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignalGenerator.js */ \"./src/SignalGenerator.js\");\n/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./View.js */ \"./src/View.js\");\n/* harmony import */ var _Model_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.js */ \"./src/Model.js\");\n/* harmony import */ var _DFT_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DFT.js */ \"./src/DFT.js\");\n/* harmony import */ var _DCT_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DCT.js */ \"./src/DCT.js\");\n/* harmony import */ var _ReverseDFT_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ReverseDFT.js */ \"./src/ReverseDFT.js\");\n/* harmony import */ var _ReverseDCT_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ReverseDCT.js */ \"./src/ReverseDCT.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n\nvar Controller = /*#__PURE__*/function () {\n  function Controller(view, model) {\n    _classCallCheck(this, Controller);\n    _defineProperty(this, \"___________________\", void 0);\n    this.view = view;\n    this.model = model;\n    this.view.setController(this);\n    this.view.initialize();\n  }\n  return _createClass(Controller, [{\n    key: \"sampleRateHandler\",\n    value: function sampleRateHandler(value) {\n      var parsedValue = parseFloat(value);\n      if (!isNaN(parsedValue) && isFinite(parsedValue) && parsedValue > 0) {\n        this.model.setSampleRate(parseFloat(value));\n        var selectedOption = this.view.selectedOption.value;\n        var amplitudeValue = parseFloat(this.view.amplitudeSlider.value);\n        var frequencyValue = parseFloat(this.view.frequencySlider.value);\n        this.updateChart(selectedOption, [amplitudeValue], [frequencyValue]);\n      } else {\n        console.error('Wrong type of input!');\n        window.alert('Wrong Type of input!');\n      }\n    }\n  }, {\n    key: \"updateChart\",\n    value: function updateChart(selectedOption) {\n      var amplitudeArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1];\n      var frequencyArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [10];\n      var customData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var _this$calculateInput = this.calculateInput(selectedOption, amplitudeArray, frequencyArray, customData),\n        labels = _this$calculateInput.labels,\n        data = _this$calculateInput.data;\n      this.model.saveSamples(data);\n      this.view.drawChart('sampleChart', labels, data, customData.length > 0 ? 'bar' : 'line', 'Entrance Signal');\n      this.view.showTransformationButtons();\n    }\n\n    //________________________________________________________________________________\n    //calculating input signal values using generateSignal() method and SignalGenerator class\n  }, {\n    key: \"calculateInput\",\n    value: function calculateInput(optionValue) {\n      var amplitudeArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1];\n      var frequencyArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [10];\n      var customData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var labels = [];\n      var data = [];\n      if (customData.length > 0) {\n        labels = Array.from({\n          length: customData.length\n        }, function (_, i) {\n          return i.toString();\n        });\n        data = customData;\n      } else {\n        switch (optionValue) {\n          case 'Sine function':\n            ;\n            var _this$generateSignal = this.generateSignal(_SignalGenerator_js__WEBPACK_IMPORTED_MODULE_0__.SignalGenerator.generateSineWave, amplitudeArray, frequencyArray);\n            labels = _this$generateSignal.labels;\n            data = _this$generateSignal.data;\n            break;\n          case 'Square function':\n            ;\n            var _this$generateSignal2 = this.generateSignal(_SignalGenerator_js__WEBPACK_IMPORTED_MODULE_0__.SignalGenerator.generateSquareWave, amplitudeArray, frequencyArray);\n            labels = _this$generateSignal2.labels;\n            data = _this$generateSignal2.data;\n            break;\n          case 'Triangle function':\n            ;\n            var _this$generateSignal3 = this.generateSignal(_SignalGenerator_js__WEBPACK_IMPORTED_MODULE_0__.SignalGenerator.generateTriangleWave, amplitudeArray, frequencyArray);\n            labels = _this$generateSignal3.labels;\n            data = _this$generateSignal3.data;\n            break;\n          default:\n            labels = Array.from({\n              length: customData.length\n            }, function (_, i) {\n              return i.toString();\n            });\n            data = customData;\n            break;\n        }\n      }\n      return {\n        labels: labels,\n        data: data\n      };\n    }\n    //________________________________________________________________________________\n  }, {\n    key: \"generateSignal\",\n    value: function generateSignal(generatorFunction, amplitudeArray, frequencyArray) {\n      var _this = this;\n      var labels = [];\n      var data = [];\n      //const duration = 1 // 1 second\n      //const length = this.model.getSampleRate() * duration\n\n      //testing\n      var numberOfPeriods = 5;\n      var maxFrequency = Math.max.apply(Math, _toConsumableArray(frequencyArray));\n      var period = 1 / maxFrequency;\n      var duration = numberOfPeriods * period;\n      //const duration=numberOfPeriods/maxFrequency\n      var length = Math.floor(this.model.getSampleRate() * duration);\n\n      // Generate the signals for all amplitudes and frequencies\n      var waveMapArray = amplitudeArray.map(function (amplitude, index) {\n        return generatorFunction(frequencyArray[index], amplitude, _this.model.getSampleRate(), length);\n      });\n\n      //testing\n      var _loop = function _loop() {\n        var t = i / _this.model.getSampleRate(); // Time value for current sample\n        var value = 0;\n        waveMapArray.forEach(function (waveMap) {\n          // Snap the time to avoid floating-point precision issues\n          var snappedTime = parseFloat(t.toFixed(10));\n          if (waveMap.has(snappedTime)) {\n            value += waveMap.get(snappedTime);\n          }\n        });\n        labels.push(t.toFixed(3));\n        data.push(value.toFixed(6));\n      };\n      for (var i = 0; i < length; i++) {\n        _loop();\n      }\n\n      // Sum the values at each time point\n      //    for (let i = 0; i < length; i++) {\n      //      const t = Number((i / this.model.getSampleRate()).toFixed(3))\n      //      let value = 0\n      //      waveMapArray.forEach((waveMap) => {\n      //        if (waveMap.has(t)) {\n      //          value += waveMap.get(t)\n      //        }\n      //      })\n      //      labels.push(t.toFixed(3))\n      //      data.push(value.toFixed(6))\n      //    }\n\n      return {\n        labels: labels,\n        data: data\n      };\n    }\n\n    //________________________________________________________________________________\n    //pass parameters to view method which will add point to HTML list\n  }, {\n    key: \"addElementToList\",\n    value: function addElementToList(selectedOption, amplitude, frequency) {\n      var element = {\n        selectedOption: selectedOption,\n        amplitude: parseFloat(amplitude),\n        frequency: parseFloat(frequency)\n      };\n      this.view.addElementToListView(element);\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"checkIfNumber\",\n    value: function checkIfNumber(value) {\n      var stringNumber = String(value).trim();\n      var regex = /^(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?)$/;\n      var parsedNumber = Number(stringNumber);\n      if (!isNaN(parsedNumber) && stringNumber === String(parsedNumber)) {\n        console.log('Input value is correct number');\n        return true;\n      } else {\n        window.alert('Incorrect input! Must provide number');\n        throw new Error('Incorrect input! Must provide number');\n      }\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"addElementToListHandler\",\n    value: function addElementToListHandler() {\n      var selectedOption = document.querySelector('.composerSelect').value;\n      var amplitude = document.querySelector('.amplitudeComposerInput').value;\n      var frequency = document.querySelector('.frequencyComposerInput').value;\n      if (this.checkIfNumber(parseFloat(amplitude)) && this.checkIfNumber(parseFloat(frequency))) {\n        this.addElementToList(selectedOption, amplitude, frequency);\n      }\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"addCloseButtons\",\n    value: function addCloseButtons() {\n      var items = this.view.getSignalListElements();\n      for (var i = 0; i < items.length; i++) {\n        var span = document.createElement('SPAN');\n        var txt = document.createTextNode(\"\\xD7\");\n        span.appendChild(txt);\n        items[i].appendChild(span);\n      }\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"addCloseButton\",\n    value: function addCloseButton(item) {\n      if (!item.querySelector('.close')) {\n        var span = document.createElement('SPAN');\n        var txt = document.createTextNode(\"\\xD7\");\n        span.className = 'close';\n        span.appendChild(txt);\n        item.appendChild(span);\n      }\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"generateCombinedSignal\",\n    value: function generateCombinedSignal() {\n      var _this2 = this;\n      var signals = Array.from(this.view.list.querySelectorAll('.signalElement')).map(function (li) {\n        var parts = li.textContent.split(' - Amplitude: ');\n        var selectedOption = parts[0];\n        var _parts$1$split$map = parts[1].split(', Frequency: ').map(parseFloat),\n          _parts$1$split$map2 = _slicedToArray(_parts$1$split$map, 2),\n          amplitude = _parts$1$split$map2[0],\n          frequency = _parts$1$split$map2[1];\n        return {\n          selectedOption: selectedOption,\n          amplitude: amplitude,\n          frequency: frequency\n        };\n      });\n      var duration = 1;\n      var length = this.model.getSampleRate() * duration;\n      var combinedWave = new Map();\n      signals.forEach(function (signal) {\n        var wave;\n        switch (signal.selectedOption) {\n          case 'Sine function':\n            wave = _SignalGenerator_js__WEBPACK_IMPORTED_MODULE_0__.SignalGenerator.generateSineWave(signal.frequency, signal.amplitude, _this2.model.getSampleRate(), length);\n            break;\n          case 'Square function':\n            wave = _SignalGenerator_js__WEBPACK_IMPORTED_MODULE_0__.SignalGenerator.generateSquareWave(signal.frequency, signal.amplitude, _this2.model.getSampleRate(), length);\n            break;\n          case 'Triangle function':\n            wave = _SignalGenerator_js__WEBPACK_IMPORTED_MODULE_0__.SignalGenerator.generateTriangleWave(signal.frequency, signal.amplitude, _this2.model.getSampleRate(), length);\n            break;\n          default:\n            return;\n        }\n        wave.forEach(function (value, key) {\n          if (!combinedWave.has(key)) {\n            combinedWave.set(key, 0);\n          }\n          combinedWave.set(key, combinedWave.get(key) + value);\n        });\n      });\n      var labels = Array.from(combinedWave.keys());\n      var data = Array.from(combinedWave.values());\n      var fixedLabels = [];\n      var fixedData = [];\n      labels.forEach(function (label) {\n        return fixedLabels.push(label);\n      });\n      data.forEach(function (element) {\n        return fixedData.push(element);\n      });\n      this.model.saveSamples(data);\n      this.view.drawChart('sampleChart', labels, data, 'line', 'Entrance Signal');\n      this.view.showTransformationButtons();\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"addCloseEventListeners\",\n    value: function addCloseEventListeners(item) {\n      item.querySelector('.close').addEventListener('click', function (event) {\n        var div = event.target.parentElement;\n        div.remove(); //remove element on close button click\n      });\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"convertToPointFormat\",\n    value: function convertToPointFormat(transformResults) {\n      return function (value, index) {\n        return {\n          x: index,\n          y: value\n        };\n      };\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"handleDFT\",\n    value: function handleDFT() {\n      var samples = this.model.samples;\n      if (!samples || samples.length === 0) {\n        return;\n      }\n      var dft = new _DFT_js__WEBPACK_IMPORTED_MODULE_3__.DFT(samples);\n      var result = dft.transform();\n      this.model.saveDFT(result);\n      //console.log('to idzie do modelu ' + result)\n      // console.log(result)\n      var amplitude = dft.getAmplitude(result);\n      var phase = dft.getPhase(result);\n      var labels = Array.from({\n        length: result.length\n      }, function (_, i) {\n        return i.toString();\n      });\n      var amplitudePoints = amplitude.map(this.convertToPointFormat(amplitude));\n      var phasePoints = phase.map(this.convertToPointFormat(phase));\n      phasePoints.forEach(function (phase) {});\n      this.view.drawAmplitudeAndPhaseChart(labels, amplitudePoints, phasePoints);\n      this.view.showModificationButtons();\n      this.view.showReverseTransformationButton();\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"handleDCT\",\n    value: function handleDCT() {\n      var samples = this.model.samples;\n      if (!samples || samples.length === 0) {\n        return;\n      }\n      var dct = new _DCT_js__WEBPACK_IMPORTED_MODULE_4__.DCT(samples);\n      var result = dct.transform();\n      this.model.saveDCT(result);\n      var amplitude = dct.getAmplitude(result);\n      var labels = Array.from({\n        length: result.length\n      }, function (_, i) {\n        return i.toString();\n      });\n      var amplitudePoints = amplitude.map(this.convertToPointFormat(amplitude));\n      amplitudePoints.forEach(function (amp) {});\n      this.view.drawAmplitudeAndPhaseChart(labels, amplitudePoints, false);\n      this.view.showModificationButtons();\n      this.view.showReverseTransformationButton();\n      //this.view.killModificationButtons()\n      //this.view.killReverseTransformationButton()\n    }\n\n    //________________________________________________________________________________\n    //  handleTimeShift(timeShiftValue) {\n    //    const N = this.model.getSamplesCount()\n    //    const kArray = Array.from({ length: N }, (_, k) => k)\n    //    const actualDFT =\n    //      this.model.getModifiedDFT().length > 0\n    //        ? this.model.getModifiedDFT()\n    //        : this.model.getDFTResults()\n    //    const originalDFT = this.model.getDFTResults()\n    //    const shiftedDFT = actualDFT.map((X_k, k) => {\n    //      const angle = (-2 * Math.PI * k * timeShiftValue) / N\n    //      return {\n    //        real: X_k.real * Math.cos(angle) - X_k.imag * Math.sin(angle),\n    //        imag: X_k.real * Math.sin(angle) + X_k.imag * Math.cos(angle),\n    //      }\n    //    })\n    //    this.model.saveModifiedDFT(shiftedDFT)\n    //    const amplitudeOriginal = originalDFT.map((X_k) =>\n    //      Math.sqrt(X_k.real ** 2 + X_k.imag ** 2),\n    //    )\n    //    const amplitudeShifted = shiftedDFT.map((X_k) =>\n    //      Math.sqrt(X_k.real ** 2 + X_k.imag ** 2),\n    //    )\n    //    const phaseOriginal = originalDFT.map((X_k) =>\n    //      Math.atan2(X_k.imag, X_k.real),\n    //    )\n    //    const phaseShifted = shiftedDFT.map((X_k) => Math.atan2(X_k.imag, X_k.real))\n    //    const amplitudeOriginalPoints = amplitudeOriginal.map(\n    //      this.convertToPointFormat(amplitudeOriginal),\n    //    )\n    //    const phaseOriginalPoints = phaseOriginal.map(\n    //      this.convertToPointFormat(phaseOriginal),\n    //    )\n    //    const amplitudeShiftedPoints = amplitudeShifted.map(\n    //      this.convertToPointFormat(amplitudeShifted),\n    //    )\n    //    const phaseShiftedPoints = phaseShifted.map(\n    //      this.convertToPointFormat(phaseShifted),\n    //    )\n    //    this.view.drawShiftedDFTChart(\n    //      kArray,\n    //      { amplitude: amplitudeOriginalPoints, phase: phaseOriginalPoints },\n    //      { amplitude: amplitudeShiftedPoints, phase: phaseShiftedPoints },\n    //    )\n    //  }\n    //testing\n    //dodatkowe handlery modfyikacji zeby view nie mial dostepu do modelu\n  }, {\n    key: \"timeShiftViewHandler\",\n    value: function timeShiftViewHandler(shiftValue) {\n      if (this.model.getCurrentTransformation() === 'DFT') {\n        this.handleDFTTimeShift(shiftValue);\n      } else {\n        this.handleDCTTimeShift(shiftValue);\n      }\n    }\n  }, {\n    key: \"amplitudeScaleViewHandler\",\n    value: function amplitudeScaleViewHandler(scaleFactor) {\n      if (this.model.getCurrentTransformation() === 'DFT') {\n        this.handleDFTAmplitudeScaling(scaleFactor);\n      } else {\n        this.handleDCTAmplitudeScaling(scaleFactor);\n      }\n    }\n\n    //to zrobic handleDFTTimeShift!!\n    //handleTimeShift(timeShiftValue) {\n  }, {\n    key: \"handleDFTTimeShift\",\n    value: function handleDFTTimeShift(timeShiftValue) {\n      var N = this.model.getSamplesCount();\n      var kArray = Array.from({\n        length: N\n      }, function (_, k) {\n        return k;\n      });\n      var actualDFT = this.model.getModifiedDFT().length > 0 ? this.model.getModifiedDFT() : this.model.getDFTResults();\n      var originalDFT = this.model.getDFTResults();\n\n      // Poprawiona implementacja przesunięcia czasowego\n      var shiftedDFT = actualDFT.map(function (X_k, k) {\n        var angle = -2 * Math.PI * k * timeShiftValue / N;\n        var magnitude = Math.sqrt(Math.pow(X_k.real, 2) + Math.pow(X_k.imag, 2));\n        var phase = Math.atan2(X_k.imag, X_k.real);\n        var newPhase = phase - angle;\n        return {\n          real: magnitude * Math.cos(newPhase),\n          imag: magnitude * Math.sin(newPhase)\n        };\n      });\n      this.model.saveModifiedDFT(shiftedDFT);\n\n      // Obliczanie amplitudy i fazy dla oryginalnego i przesuniętego sygnału\n      var amplitudeOriginal = originalDFT.map(function (X_k) {\n        return Math.sqrt(Math.pow(X_k.real, 2) + Math.pow(X_k.imag, 2));\n      });\n      var amplitudeShifted = shiftedDFT.map(function (X_k) {\n        return Math.sqrt(Math.pow(X_k.real, 2) + Math.pow(X_k.imag, 2));\n      });\n      var phaseOriginal = originalDFT.map(function (X_k) {\n        return Math.atan2(X_k.imag, X_k.real);\n      });\n      var phaseShifted = shiftedDFT.map(function (X_k) {\n        return Math.atan2(X_k.imag, X_k.real);\n      });\n\n      // Konwersja do formatu punktów\n      var amplitudeOriginalPoints = amplitudeOriginal.map(this.convertToPointFormat(amplitudeOriginal));\n      var phaseOriginalPoints = phaseOriginal.map(this.convertToPointFormat(phaseOriginal));\n      var amplitudeShiftedPoints = amplitudeShifted.map(this.convertToPointFormat(amplitudeShifted));\n      var phaseShiftedPoints = phaseShifted.map(this.convertToPointFormat(phaseShifted));\n\n      // Aktualizacja wykresu\n      this.view.drawShiftedDFTChart(kArray, {\n        amplitude: amplitudeOriginalPoints,\n        phase: phaseOriginalPoints\n      }, {\n        amplitude: amplitudeShiftedPoints,\n        phase: phaseShiftedPoints\n      });\n    }\n\n    //________________________________________________________________________________\n    //working on\n    //_________________________________\n  }, {\n    key: \"handleDCTTimeShift\",\n    value: function handleDCTTimeShift(shiftValue) {\n      var samples = this.model.getSamples();\n      if (!samples || samples.length === 0) return;\n\n      // Shifted signal\n      var shiftedSamples = samples.map(function (_, index) {\n        var newIndex = (index + shiftValue) % samples.length;\n        return samples[newIndex];\n      });\n\n      // Save shifted and original samples\n      this.model.saveSamples(shiftedSamples);\n      var originalSamples = this.model.getSamples();\n      var N = this.model.getSamplesCount();\n      var kArray = Array.from({\n        length: N\n      }, function (_, k) {\n        return k;\n      });\n\n      // DCT for original and shifted signals\n      var dctOriginal = new _DCT_js__WEBPACK_IMPORTED_MODULE_4__.DCT(originalSamples);\n      var dctShifted = new _DCT_js__WEBPACK_IMPORTED_MODULE_4__.DCT(shiftedSamples);\n      var originalDCT = dctOriginal.transform();\n      var shiftedDCT = dctShifted.transform();\n      var amplitudeOriginal = dctOriginal.getAmplitude(originalDCT);\n      var amplitudeShifted = dctShifted.getAmplitude(shiftedDCT);\n\n      // Points for plotting\n      var amplitudeOriginalPoints = amplitudeOriginal.map(this.convertToPointFormat(amplitudeOriginal));\n      var amplitudeShiftedPoints = amplitudeShifted.map(this.convertToPointFormat(amplitudeShifted));\n\n      // Draw the chart\n      this.view.drawShiftedDCTChart(kArray, {\n        amplitude: amplitudeOriginalPoints\n      }, {\n        amplitude: amplitudeShiftedPoints\n      });\n    }\n    //_______________________________________________\n    //working on\n    //________________________________\n    // _____________________________\n  }, {\n    key: \"handleDCTAmplitudeScaling\",\n    value: function handleDCTAmplitudeScaling(scaleFactor) {\n      var samples = this.model.getSamples();\n      if (!samples || samples.length === 0) return;\n\n      // Scaled samples\n      var scaledSamples = samples.map(function (sample) {\n        return sample * scaleFactor;\n      });\n\n      // Save both original and scaled samples\n      this.model.saveSamples(scaledSamples);\n      var originalSamples = this.model.getSamples();\n      var N = this.model.getSamplesCount();\n      var kArray = Array.from({\n        length: N\n      }, function (_, k) {\n        return k;\n      });\n\n      // DCT for original and scaled signals\n      var dctOriginal = new _DCT_js__WEBPACK_IMPORTED_MODULE_4__.DCT(originalSamples);\n      var dctScaled = new _DCT_js__WEBPACK_IMPORTED_MODULE_4__.DCT(scaledSamples);\n      var originalDCT = dctOriginal.transform();\n      var scaledDCT = dctScaled.transform();\n      var amplitudeOriginal = dctOriginal.getAmplitude(originalDCT);\n      var amplitudeScaled = dctScaled.getAmplitude(scaledDCT);\n\n      // Points for plotting\n      var amplitudeOriginalPoints = amplitudeOriginal.map(this.convertToPointFormat(amplitudeOriginal));\n      var amplitudeScaledPoints = amplitudeScaled.map(this.convertToPointFormat(amplitudeScaled));\n\n      // Draw the chart\n      this.view.drawShiftedDCTChart(kArray, {\n        amplitude: amplitudeOriginalPoints\n      }, {\n        amplitude: amplitudeScaledPoints\n      });\n    }\n  }, {\n    key: \"handleDFTAmplitudeScaling\",\n    value:\n    //to zrobic handleDCTAmpscale!!\n    //  handleAmplitudeScaling(scaleFactor) {\n    function handleDFTAmplitudeScaling(scaleFactor) {\n      var N = this.model.getSamplesCount();\n      var kArray = Array.from({\n        length: N\n      }, function (_, k) {\n        return k;\n      });\n      var originalDFT = this.model.getDFTResults();\n      var actualDFT = this.model.getModifiedDFT().length > 0 ? this.model.getModifiedDFT() : this.model.getDFTResults();\n      var scaledDFT = actualDFT.map(function (X_k) {\n        return {\n          real: X_k.real * scaleFactor,\n          imag: X_k.imag * scaleFactor\n        };\n      });\n      this.model.saveModifiedDFT(scaledDFT);\n      var amplitudeOriginal = originalDFT.map(function (X_k) {\n        return Math.sqrt(Math.pow(X_k.real, 2) + Math.pow(X_k.imag, 2));\n      });\n      var amplitudeShifted = scaledDFT.map(function (X_k) {\n        return Math.sqrt(Math.pow(X_k.real, 2) + Math.pow(X_k.imag, 2));\n      });\n      var phaseOriginal = originalDFT.map(function (X_k) {\n        return Math.atan2(X_k.imag, X_k.real);\n      });\n      var phaseShifted = scaledDFT.map(function (X_k) {\n        return Math.atan2(X_k.imag, X_k.real);\n      });\n      var amplitudeOriginalPoints = amplitudeOriginal.map(this.convertToPointFormat(amplitudeOriginal));\n      var phaseOriginalPoints = phaseOriginal.map(this.convertToPointFormat(phaseOriginal));\n      var amplitudeShiftedPoints = amplitudeShifted.map(this.convertToPointFormat(amplitudeShifted));\n      var phaseShiftedPoints = phaseShifted.map(this.convertToPointFormat(phaseShifted));\n      this.view.drawShiftedDFTChart(kArray, {\n        amplitude: amplitudeOriginalPoints,\n        phase: phaseOriginalPoints\n      }, {\n        amplitude: amplitudeShiftedPoints,\n        phase: phaseShiftedPoints\n      });\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"clearModSignal\",\n    value: function clearModSignal() {\n      this.model.clearModDFT();\n      this.model.clearModDCT();\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"clearStorage\",\n    value: function clearStorage() {\n      this.model.clearLocalStorage();\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"handleReverseTransform\",\n    value: function handleReverseTransform() {\n      if (this.model.getCurrentTransformation() === 'DFT') {\n        this.handleReverseDFT();\n      } else {\n        this.handleReverseDCT();\n      }\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"handleReverseDFT\",\n    value: function handleReverseDFT() {\n      var _this3 = this;\n      var dftResults = this.model.getModifiedDFT().length > 0 ? this.model.getModifiedDFT() : this.model.getDFTResults();\n      if (!dftResults || dftResults.length === 0) {\n        return;\n      }\n      // console.log('tu cos powinienem wyciagnac z modelu ')\n      // console.log(this.model.getDFTResults())\n      var reverseDFT = new _ReverseDFT_js__WEBPACK_IMPORTED_MODULE_5__.ReverseDFT(dftResults);\n      var reverseDFTResults = reverseDFT.reverseTransform();\n      var labels = Array.from({\n        length: reverseDFTResults.length\n      }, function (_, i) {\n        return (i / _this3.model.getSampleRate()).toString();\n      });\n      this.model.saveReverseDFT(reverseDFTResults);\n      //console.log(reverseDFTResults)\n      this.view.drawTimeDomainChart(labels, reverseDFTResults);\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"handleReverseDCT\",\n    value: function handleReverseDCT() {\n      var _this4 = this;\n      var dctResults = this.model.getModifiedDCT().length > 0 ? this.model.getModifiedDCT() : this.model.getDCTResults();\n      if (!dctResults || dctResults.length === 0) {\n        return;\n      }\n      var reverseDCT = new _ReverseDCT_js__WEBPACK_IMPORTED_MODULE_6__.ReverseDCT(dctResults);\n      var reverseDCTResults = reverseDCT.reverseTransform();\n      var labels = Array.from({\n        length: reverseDCTResults.length\n      }, function (_, i) {\n        return (i / _this4.model.getSampleRate()).toString();\n      });\n      this.model.saveReverseDCT(reverseDCTResults);\n      this.view.drawTimeDomainChart(labels, reverseDCTResults);\n    }\n    //________________________________________________________________________________\n\n    //________________________________________________________________________________\n  }, {\n    key: \"saveSignals\",\n    value: function saveSignals() {\n      var signals = Array.from(this.view.list.querySelectorAll('.signalElement')).map(function (li) {\n        var parts = li.textContent.split(' - Amplitude: ');\n        var selectedOption = parts[0];\n        var _parts$1$split$map3 = parts[1].split(', Frequency: ').map(parseFloat),\n          _parts$1$split$map4 = _slicedToArray(_parts$1$split$map3, 2),\n          amplitude = _parts$1$split$map4[0],\n          frequency = _parts$1$split$map4[1];\n        return {\n          selectedOption: selectedOption,\n          amplitude: amplitude,\n          frequency: frequency\n        };\n      });\n      this.model.saveSignalsToLocalStorage(signals);\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"loadSignals\",\n    value: function loadSignals() {\n      var _this5 = this;\n      var signals = this.model.loadSignalsFromLocalStorage();\n      this.view.clearSignalList();\n      signals.forEach(function (signal) {\n        _this5.view.addElementToListView(signal);\n      });\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"saveSamples\",\n    value: function saveSamples() {\n      var samples = this.view.textArea.value.split('\\n').filter(function (sample) {\n        return sample.trim() !== '';\n      });\n      this.model.saveSamplesToLocalStorage(samples);\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"loadSamples\",\n    value: function loadSamples() {\n      var samples = this.model.loadSamplesFromLocalStorage();\n      this.view.textArea.value = samples.join('\\n');\n    }\n\n    //________________________________________________________________________________\n  }, {\n    key: \"setTransformationType\",\n    value: function setTransformationType(type) {\n      this.model.setCurrentTransformation(type);\n    }\n\n    //________________________________________________________________________________\n  }]);\n}();\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/Controller.js?");

/***/ }),

/***/ "./src/DCT.js":
/*!********************!*\
  !*** ./src/DCT.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DCT: () => (/* binding */ DCT)\n/* harmony export */ });\n/* harmony import */ var _Transformation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transformation.js */ \"./src/Transformation.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar DCT = /*#__PURE__*/function (_Transformation) {\n  function DCT(probes) {\n    _classCallCheck(this, DCT);\n    return _callSuper(this, DCT, [probes]);\n  }\n  _inherits(DCT, _Transformation);\n  return _createClass(DCT, [{\n    key: \"transform\",\n    value: function transform() {\n      var N = this.probes.length;\n      var X = [];\n      for (var k = 0; k < N; k++) {\n        var sum = 0;\n        for (var n = 0; n < N; n++) {\n          var angle = Math.PI * k * (2 * n + 1) / (2 * N);\n          sum += this.probes[n] * Math.cos(angle);\n        }\n        X.push(sum);\n      }\n      this.clearSpectrum(X);\n      return X;\n    }\n  }, {\n    key: \"clearSpectrum\",\n    value: function clearSpectrum(X) {\n      var maxAmp = Math.max.apply(Math, _toConsumableArray(X.map(function (r) {\n        return Math.abs(r.real);\n      })));\n      var tol = maxAmp / 10000;\n      X.forEach(function (r, i) {\n        var amp = Math.abs(r.real);\n        if (amp < tol) {\n          X[i] = {\n            real: 0,\n            imag: 0\n          };\n        }\n      });\n    }\n  }, {\n    key: \"getAmplitude\",\n    value: function getAmplitude(dctResults) {\n      return dctResults;\n    }\n  }]);\n}(_Transformation_js__WEBPACK_IMPORTED_MODULE_0__.Transformation);\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/DCT.js?");

/***/ }),

/***/ "./src/DFT.js":
/*!********************!*\
  !*** ./src/DFT.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DFT: () => (/* binding */ DFT)\n/* harmony export */ });\n/* harmony import */ var _Transformation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transformation.js */ \"./src/Transformation.js\");\n/* harmony import */ var fft_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fft-js */ \"./node_modules/fft-js/index.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar DFT = /*#__PURE__*/function (_Transformation) {\n  function DFT(probes) {\n    _classCallCheck(this, DFT);\n    //access properties on an object literal or class's [[Protype]]\n    return _callSuper(this, DFT, [probes]); //    console.log(probes)\n    //const simpleInput = [[1, 0], [0, 0], [0, 0], [0, 0]];\n    //const fftResult = fft(simpleInput);\n    //console.log('Test FFT Result:', fftResult);\n  }\n  //first attemp at implementing algorithm\n  _inherits(DFT, _Transformation);\n  return _createClass(DFT, [{\n    key: \"transform\",\n    value: function transform() {\n      var N = this.probes.length;\n      var X = [];\n      for (var k = 0; k < N; k++) {\n        var sum = {\n          real: 0,\n          imag: 0\n        };\n        for (var n = 0; n < N; n++) {\n          var angle = -2 * Math.PI * k * n / N;\n          sum.real += this.probes[n] * Math.cos(angle);\n          sum.imag += this.probes[n] * Math.sin(angle);\n          sum.real = parseFloat(sum.real.toFixed(4));\n          sum.imag = parseFloat(sum.imag.toFixed(4));\n        }\n        X.push(sum);\n      }\n      this.clearSpectrum(X);\n      return X;\n    }\n\n    //  bruteForceDFTtransform() {\n    //    const N = this.probes.length\n    //    const X = []\n    //    for (let k = 0; k < N; k++) {\n    //      let sum = { real: 0, imag: 0 }\n    //      for (let n = 0; n < N; n++) {\n    //        const angle = (-2 * Math.PI * k * n) / N\n    //        sum.real += this.probes[n] * Math.cos(angle)\n    //        sum.imag += this.probes[n] * Math.sin(angle)\n    //        sum.real = parseFloat(sum.real.toFixed(4))\n    //        sum.imag = parseFloat(sum.imag.toFixed(4))\n    //      }\n    //      X.push(sum)\n    //    }\n    //    this.clearSpectrum(X)\n    //    return X\n    //  }\n  }, {\n    key: \"bruteForceDFTtransform\",\n    value: function bruteForceDFTtransform(probes) {\n      var N = probes.length;\n      var X = [];\n      for (var k = 0; k < N; k++) {\n        var sum = {\n          real: 0,\n          imag: 0\n        };\n        for (var n = 0; n < N; n++) {\n          var angle = -2 * Math.PI * k * n / N;\n          sum.real += probes[n] * Math.cos(angle);\n          sum.imag += probes[n] * Math.sin(angle);\n          sum.real = parseFloat(sum.real.toFixed(4));\n          sum.imag = parseFloat(sum.imag.toFixed(4));\n        }\n        X.push(sum);\n      }\n      this.clearSpectrum(X);\n      return X;\n    }\n    //_______________________________________________________________\n    //attemp at using npm package for DFT\n    //  transform() {\n    //    const newLength = 2 ** Math.ceil(Math.log2(this.probes.length))\n    //    this.probes = this.fillWithZeros(newLength) // Ensure length is a power of 2\n    //    const N = this.probes.length\n    //\n    //    if ((N & (N - 1)) !== 0) {\n    //      console.error(`Liczba próbek musi być potęgą 2 dla FFT: ${N}`)\n    //      return []\n    //    }\n    //\n    //    //____________________________________________________\n    //    //testy\n    //    //    const testArrayFirst=[1,1,1,1]\n    //    //    const testArraySecond=[1,0,1,0]\n    //    //    const testArrayThird=[2,3,1,12,22,7,13,19]\n    //    //    const calcDFTfirst=this.bruteForceDFTtransform(testArrayFirst);\n    //    //    const calcDFTsecond=this.bruteForceDFTtransform(testArraySecond);\n    //    //    const calcDFTthird=this.bruteForceDFTtransform(testArrayThird);\n    //    //      console.log(`input to ${testArrayFirst} jego fft to ${JSON.stringify(fft(testArrayFirst))} a moje dft to ${JSON.stringify(calcDFTfirst)}`);\n    //    //\n    //    //  console.log(`input to ${testArraySecond} jego fft to ${JSON.stringify(fft(testArraySecond))} a moje dft to ${JSON.stringify(calcDFTsecond)}`);\n    //    //\n    //    //  console.log(`input to ${testArrayThird} jego fft to ${JSON.stringify(fft(testArrayThird))} a moje dft to ${JSON.stringify(calcDFTthird)}`);\n    //    //    console.log(`moj input to ${JSON.stringify(this.probes)}`)\n    //    //____________________________________________________\n    //    const input = this.probes.map((p) => parseFloat(p) || 0)\n    //\n    //    try {\n    //      let fftResult = fft(input)\n    //      let testDFT = this.bruteForceDFTtransform(input)\n    //      console.log('fft to ' + JSON.stringify(fftResult))\n    //\n    //      const X = fftResult.map(([real, imag]) => ({\n    //        real: parseFloat(real.toFixed(4)),\n    //        imag: parseFloat(imag.toFixed(4)),\n    //      }))\n    //\n    //      for (let kj = 0; kj < testDFT.length; kj++) {\n    //        console.log(`real ${X[kj].real} i imag ${X[kj].imag}`)\n    //\n    //        console.log(\n    //          `real ${X[kj].real - testDFT[kj].real} i imag ${X[kj].imag - testDFT[kj].imag}`,\n    //        )\n    //      }\n    //\n    //      //console.log('Parsed FFT Result:', X)\n    //\n    //      this.clearSpectrum(X)\n    //      return X\n    //    } catch (error) {\n    //      console.error('Bład w przy liczeniu FFT')\n    //      return []\n    //    }\n    //  }\n\n    //testing\n\n    //transform() {\n    //    const N = this.probes.length;\n    //    const paddedLength = 2 ** Math.ceil(Math.log2(N));\n    //    const paddedProbes = this.fillWithZeros(paddedLength);\n    //\n    //    //const input = paddedProbes.map(p => [parseFloat(p) || 0, 0]);\n    //    const input = paddedProbes.map((p) => parseFloat(p) || 0)\n    //    \n    //    try {\n    //      const fftResult = fft(input);\n    //      const X = fftResult.map(([real, imag]) => ({\n    //        real: parseFloat(real.toFixed(4)),\n    //        imag: parseFloat(imag.toFixed(4))\n    //      }));\n    //\n    //      this.clearSpectrum(X);\n    //      return X;\n    //    } catch (error) {\n    //      console.error('Błąd przy liczeniu FFT:', error);\n    //      return [];\n    //    }\n    //  }\n\n    //_______________________________________________________________\n  }, {\n    key: \"clearSpectrum\",\n    value: function clearSpectrum(X) {\n      var maxAmp = Math.max.apply(Math, _toConsumableArray(X.map(function (r) {\n        return Math.sqrt(Math.pow(r.real, 2) + Math.pow(r.imag, 2));\n      })));\n      var tol = maxAmp / 10000;\n      X.forEach(function (r, i) {\n        var amp = Math.sqrt(Math.pow(r.real, 2) + Math.pow(r.imag, 2));\n        if (amp < tol) {\n          X[i] = {\n            real: 0,\n            imag: 0\n          };\n        }\n      });\n    }\n\n    //testing\n  }, {\n    key: \"getAmplitude\",\n    value: function getAmplitude(dftResults) {\n      var _this = this;\n      return dftResults.map(function (r) {\n        return parseFloat((Math.sqrt(Math.pow(r.real, 2) + Math.pow(r.imag, 2)) * 2 / _this.probes.length).toFixed(4));\n      });\n    }\n\n    //  getAmplitude(dftResults) {\n    //    return dftResults.map((r) =>\n    //      parseFloat(Math.sqrt(r.real ** 2 + r.imag ** 2).toFixed(4)),\n    //    )\n    //  }\n\n    //testing\n  }, {\n    key: \"getPhase\",\n    value: function getPhase(dftResults) {\n      var amplitudes = this.getAmplitude(dftResults);\n      var maxAmp = Math.max.apply(Math, _toConsumableArray(amplitudes));\n      var threshold = maxAmp / 2;\n      return dftResults.map(function (r, index) {\n        if (amplitudes[index] > threshold) {\n          return parseFloat((Math.atan2(r.imag, r.real) * (180 / Math.PI)).toFixed(4));\n        } else {\n          return 0;\n        }\n      });\n    }\n    //  getPhase(dftResults) {\n    //    return dftResults.map(r => {\n    //      if (Math.abs(r.real) < 1e-10 && Math.abs(r.imag) < 1e-10) {\n    //        return 0;\n    //      }\n    //      return parseFloat((Math.atan2(r.imag, r.real) * (180 / Math.PI)).toFixed(4));\n    //    });\n    //  }\n  }]);\n}(_Transformation_js__WEBPACK_IMPORTED_MODULE_0__.Transformation);\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/DFT.js?");

/***/ }),

/***/ "./src/Model.js":
/*!**********************!*\
  !*** ./src/Model.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Model: () => (/* binding */ Model)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Model = /*#__PURE__*/function () {\n  function Model() {\n    _classCallCheck(this, Model);\n    this.samples = JSON.parse(localStorage.getItem('samples')) || [];\n    this.dftResults = JSON.parse(localStorage.getItem('dftResults')) || [];\n    this.dctResults = JSON.parse(localStorage.getItem('dctResults')) || [];\n    this.transformationType = 'DFT';\n    this.savedSignalsKey = 'savedSignals';\n    this.savedSamplesKey = 'savedSamples';\n    this.modifiedDftResults = JSON.parse(localStorage.getItem('modifiedDftResults')) || [];\n    this.reverseDFTResults = JSON.parse(localStorage.getItem('reverseDFTResults')) || [];\n    this.sampleRate = JSON.parse(localStorage.getItem('sampleRate')) || 100;\n    this.modifiedDctResults = JSON.parse(localStorage.getItem('modifiedDctResults')) || [];\n    this.reverseDCTResults = JSON.parse(localStorage.getItem('reverseDCTResults')) || [];\n  }\n  return _createClass(Model, [{\n    key: \"setCurrentTransformation\",\n    value: function setCurrentTransformation(type) {\n      this.transformationType = type;\n    }\n  }, {\n    key: \"getCurrentTransformation\",\n    value: function getCurrentTransformation() {\n      return this.transformationType;\n    }\n  }, {\n    key: \"setSampleRate\",\n    value: function setSampleRate(sampleRate) {\n      this.sampleRate = sampleRate;\n      localStorage.setItem('sampleRate', JSON.stringify(sampleRate));\n    }\n  }, {\n    key: \"saveSamples\",\n    value: function saveSamples(samples) {\n      this.samples = samples;\n      localStorage.setItem('samples', JSON.stringify(samples));\n    }\n  }, {\n    key: \"saveDFT\",\n    value: function saveDFT(dftResults) {\n      this.dftResults = dftResults;\n      localStorage.setItem('dftResults', JSON.stringify(dftResults));\n    }\n  }, {\n    key: \"saveDCT\",\n    value: function saveDCT(dctResults) {\n      this.dctResults = dctResults;\n      localStorage.setItem('dctResults', JSON.stringify(dctResults));\n    }\n  }, {\n    key: \"saveModifiedDFT\",\n    value: function saveModifiedDFT(modifiedDftResults) {\n      this.modifiedDftResults = modifiedDftResults;\n      localStorage.setItem('modifiedDftResults', JSON.stringify(modifiedDftResults));\n    }\n  }, {\n    key: \"saveReverseDFT\",\n    value: function saveReverseDFT(reverseDFTResults) {\n      this.reverseDFTResults = reverseDFTResults;\n      localStorage.setItem('reverseDFTResults', JSON.stringify(reverseDFTResults));\n    }\n  }, {\n    key: \"saveModifiedDCT\",\n    value: function saveModifiedDCT(modifiedDctResults) {\n      this.modifiedDctResults = modifiedDctResults;\n      localStorage.setItem('modifiedDctResults', JSON.stringify(modifiedDctResults));\n    }\n  }, {\n    key: \"saveReverseDCT\",\n    value: function saveReverseDCT(reverseDCTResults) {\n      this.reverseDCTResults = reverseDCTResults;\n      localStorage.setItem('reverseDCTResults', JSON.stringify(reverseDCTResults));\n    }\n  }, {\n    key: \"getSamples\",\n    value: function getSamples() {\n      return this.samples;\n    }\n  }, {\n    key: \"clearModDFT\",\n    value: function clearModDFT(modifiedDftResults) {\n      if (this.modifiedDftResults) {\n        localStorage.removeItem('modifiedDftResults');\n        this.modifiedDftResults = [];\n      }\n      console.log('cleared DFT' + this.modifiedDftResults);\n    }\n  }, {\n    key: \"clearModDCT\",\n    value: function clearModDCT(modifiedDctResults) {\n      if (this.modifiedDctResults) {\n        localStorage.removeItem('modifiedDctResults');\n        this.modifiedDctResults = [];\n      }\n      console.log('cleared DCT' + this.modifiedDctResults);\n    }\n  }, {\n    key: \"clearLocalStorage\",\n    value: function clearLocalStorage() {\n      localStorage.clear();\n    }\n  }, {\n    key: \"getSampleRate\",\n    value: function getSampleRate() {\n      return this.sampleRate;\n    }\n  }, {\n    key: \"getSamplesCount\",\n    value: function getSamplesCount() {\n      return this.samples.length;\n    }\n  }, {\n    key: \"getDFTResults\",\n    value: function getDFTResults() {\n      return this.dftResults;\n    }\n  }, {\n    key: \"getDCTResults\",\n    value: function getDCTResults() {\n      return this.dctResults;\n    }\n  }, {\n    key: \"getModifiedDFT\",\n    value: function getModifiedDFT() {\n      return this.modifiedDftResults;\n    }\n  }, {\n    key: \"getReverseDFT\",\n    value: function getReverseDFT() {\n      return this.reverseDFTResults;\n    }\n  }, {\n    key: \"getModifiedDCT\",\n    value: function getModifiedDCT() {\n      return this.modifiedDctResults;\n    }\n  }, {\n    key: \"getReverseDCT\",\n    value: function getReverseDCT() {\n      return this.reverseDCTResults;\n    }\n  }, {\n    key: \"saveSignalsToLocalStorage\",\n    value: function saveSignalsToLocalStorage(signals) {\n      localStorage.setItem(this.savedSignalsKey, JSON.stringify(signals));\n    }\n  }, {\n    key: \"loadSignalsFromLocalStorage\",\n    value: function loadSignalsFromLocalStorage() {\n      var signals = localStorage.getItem(this.savedSignalsKey);\n      return signals ? JSON.parse(signals) : [];\n    }\n  }, {\n    key: \"saveSamplesToLocalStorage\",\n    value: function saveSamplesToLocalStorage(samples) {\n      localStorage.setItem(this.savedSamplesKey, JSON.stringify(samples));\n    }\n  }, {\n    key: \"loadSamplesFromLocalStorage\",\n    value: function loadSamplesFromLocalStorage() {\n      var samples = localStorage.getItem(this.savedSamplesKey);\n      return samples ? JSON.parse(samples) : [];\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/Model.js?");

/***/ }),

/***/ "./src/ReverseDCT.js":
/*!***************************!*\
  !*** ./src/ReverseDCT.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReverseDCT: () => (/* binding */ ReverseDCT)\n/* harmony export */ });\n/* harmony import */ var _ReverseTransformation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReverseTransformation.js */ \"./src/ReverseTransformation.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar ReverseDCT = /*#__PURE__*/function (_ReverseTransformatio) {\n  function ReverseDCT(signal) {\n    _classCallCheck(this, ReverseDCT);\n    return _callSuper(this, ReverseDCT, [signal]);\n  }\n  _inherits(ReverseDCT, _ReverseTransformatio);\n  return _createClass(ReverseDCT, [{\n    key: \"reverseTransform\",\n    value: function reverseTransform() {\n      var N = this.signal.length;\n      var x = [];\n      var factor = Math.PI / N;\n      for (var n = 0; n < N; n++) {\n        var sum = this.signal[0] / 2;\n        for (var k = 1; k < N; k++) {\n          var angle = factor * k * (2 * n + 1) / 2;\n          sum += this.signal[k] * Math.cos(angle);\n        }\n        x.push(sum);\n      }\n      return x;\n    }\n  }]);\n}(_ReverseTransformation_js__WEBPACK_IMPORTED_MODULE_0__.ReverseTransformation);\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/ReverseDCT.js?");

/***/ }),

/***/ "./src/ReverseDFT.js":
/*!***************************!*\
  !*** ./src/ReverseDFT.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReverseDFT: () => (/* binding */ ReverseDFT)\n/* harmony export */ });\n/* harmony import */ var _ReverseTransformation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReverseTransformation.js */ \"./src/ReverseTransformation.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar ReverseDFT = /*#__PURE__*/function (_ReverseTransformatio) {\n  function ReverseDFT(signal) {\n    _classCallCheck(this, ReverseDFT);\n    return _callSuper(this, ReverseDFT, [signal]);\n  }\n  _inherits(ReverseDFT, _ReverseTransformatio);\n  return _createClass(ReverseDFT, [{\n    key: \"reverseTransform\",\n    value: function reverseTransform() {\n      var N = this.signal.length;\n      var x = [];\n      for (var n = 0; n < N; n++) {\n        var sum = {\n          real: 0,\n          imag: 0\n        };\n        for (var k = 0; k < N; k++) {\n          var angle = 2 * Math.PI * k * n / N;\n          sum.real += this.signal[k].real * Math.cos(angle) - this.signal[k].imag * Math.sin(angle);\n          sum.imag += this.signal[k].real * Math.sin(angle) + this.signal[k].imag * Math.cos(angle);\n        }\n        console.log(sum);\n        x.push(sum.real / N);\n      }\n      return x;\n    }\n  }]);\n}(_ReverseTransformation_js__WEBPACK_IMPORTED_MODULE_0__.ReverseTransformation);\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/ReverseDFT.js?");

/***/ }),

/***/ "./src/ReverseTransformation.js":
/*!**************************************!*\
  !*** ./src/ReverseTransformation.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReverseTransformation: () => (/* binding */ ReverseTransformation)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar ReverseTransformation = /*#__PURE__*/function () {\n  function ReverseTransformation(signal) {\n    _classCallCheck(this, ReverseTransformation);\n    this.signal = signal;\n  }\n  return _createClass(ReverseTransformation, [{\n    key: \"reverseTranform\",\n    value: function reverseTranform() {\n      throw new Error('Method \"reverseTransform\" must be be implemented');\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/ReverseTransformation.js?");

/***/ }),

/***/ "./src/SignalGenerator.js":
/*!********************************!*\
  !*** ./src/SignalGenerator.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignalGenerator: () => (/* binding */ SignalGenerator)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n//class used to generate base Functions\nvar SignalGenerator = /*#__PURE__*/function () {\n  function SignalGenerator() {\n    _classCallCheck(this, SignalGenerator);\n  }\n  return _createClass(SignalGenerator, null, [{\n    key: \"generateSineWave\",\n    value: function generateSineWave(frequency) {\n      var amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var sampleRate = arguments.length > 2 ? arguments[2] : undefined;\n      var length = arguments.length > 3 ? arguments[3] : undefined;\n      var wave = new Map();\n      var angularFrequency = 2 * Math.PI * frequency;\n      var timeIncrement = 1 / sampleRate;\n      for (var i = 0; i < length; i++) {\n        var time = parseFloat((i * timeIncrement).toFixed(10));\n        wave.set(time, amplitude * Math.sin(angularFrequency * time));\n      }\n      return wave;\n    }\n    //\n    //  static generateSineWave(frequency, amplitude = 1, sampleRate, length) {\n    //    const angularFrequency = 2 * Math.PI * frequency\n    //    return (t) => amplitude * Math.sin(angularFrequency * t)\n    //  }\n  }, {\n    key: \"generateSquareWave\",\n    value: function generateSquareWave(frequency) {\n      var amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var sampleRate = arguments.length > 2 ? arguments[2] : undefined;\n      var length = arguments.length > 3 ? arguments[3] : undefined;\n      var wave = new Map();\n      var period = Math.floor(sampleRate / frequency);\n      var halfPeriod = Math.floor(period / 2);\n      var timeIncrement = 1 / sampleRate;\n      for (var i = 0; i < length; i++) {\n        var time = parseFloat((i * timeIncrement).toFixed(10));\n        var phase = i % period;\n        wave.set(time, phase < halfPeriod ? amplitude : -amplitude);\n      }\n      return wave;\n    }\n  }, {\n    key: \"generateTriangleWave\",\n    value: function generateTriangleWave(frequency) {\n      var amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var sampleRate = arguments.length > 2 ? arguments[2] : undefined;\n      var length = arguments.length > 3 ? arguments[3] : undefined;\n      var wave = new Map();\n      var period = Math.floor(sampleRate / frequency);\n      var halfPeriod = Math.floor(period / 2);\n      var timeIncrement = 1 / sampleRate;\n      for (var i = 0; i < length; i++) {\n        var time = parseFloat((i * timeIncrement).toFixed(10));\n        var t = i % period / period;\n        var value = void 0;\n        if (t < 0.25) {\n          value = 4 * t * amplitude;\n        } else if (t < 0.75) {\n          value = (-4 * t + 2) * amplitude;\n        } else {\n          value = (4 * t - 4) * amplitude;\n        }\n        wave.set(time, value);\n      }\n      return wave;\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/SignalGenerator.js?");

/***/ }),

/***/ "./src/Transformation.js":
/*!*******************************!*\
  !*** ./src/Transformation.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transformation: () => (/* binding */ Transformation)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Transformation = /*#__PURE__*/function () {\n  function Transformation(probes) {\n    _classCallCheck(this, Transformation);\n    this.probes = probes;\n  }\n  return _createClass(Transformation, [{\n    key: \"normalizeProbes\",\n    value: function normalizeProbes() {\n      var max = Math.max.apply(Math, _toConsumableArray(this.probes));\n      return this.probes.map(function (probe) {\n        return probe / max;\n      });\n    }\n  }, {\n    key: \"fillWithZeros\",\n    value: function fillWithZeros(correctLength) {\n      if (this.probes.length >= correctLength) {\n        return this.probes;\n      }\n      var filledProbes = _toConsumableArray(this.probes);\n      while (filledProbes.length < correctLength) {\n        filledProbes.push(0);\n      }\n      return filledProbes;\n    }\n  }, {\n    key: \"tranform\",\n    value: function tranform() {\n      throw new Error('Method \"transform\" must be be implemented');\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/Transformation.js?");

/***/ }),

/***/ "./src/View.js":
/*!*********************!*\
  !*** ./src/View.js ***!
  \*********************/
/***/ (() => {

eval("throw new Error(\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\nSyntaxError: C:\\\\dev\\\\dft\\\\src\\\\View.js: Invalid escape sequence in template. (754:39)\\n\\n\\u001b[0m \\u001b[90m 752 |\\u001b[39m \\u001b[32m      <button class=\\\"lowPassButton\\\">Notch</button>\\u001b[39m\\n \\u001b[90m 753 |\\u001b[39m \\u001b[32m      </div>\\u001b[39m\\n\\u001b[31m\\u001b[1m>\\u001b[22m\\u001b[39m\\u001b[90m 754 |\\u001b[39m \\u001b[32m      <button class=\\\"closeFiltersDiv\\\">\\\\u00\\u001b[39m\\n \\u001b[90m     |\\u001b[39m                                        \\u001b[31m\\u001b[1m^\\u001b[22m\\u001b[39m\\n \\u001b[90m 755 |\\u001b[39m \\u001b[32m      </div>\\u001b[39m\\n \\u001b[90m 756 |\\u001b[39m \\u001b[32m\\u001b[39m\\n \\u001b[90m 757 |\\u001b[39m \\u001b[32m       <div class=\\\"filtersHeader\\\">\\u001b[39m\\u001b[0m\\n    at constructor (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:362:19)\\n    at Parser.raise (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:3260:19)\\n    at Parser.parseTemplateElement (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:11294:14)\\n    at Parser.parseTemplate (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:11312:23)\\n    at Parser.parseExprAtom (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10881:21)\\n    at Parser.parseExprSubscripts (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10584:23)\\n    at Parser.parseUpdate (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10569:21)\\n    at Parser.parseMaybeUnary (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10549:23)\\n    at Parser.parseMaybeUnaryOrPrivate (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10403:61)\\n    at Parser.parseExprOps (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10408:23)\\n    at Parser.parseMaybeConditional (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10385:23)\\n    at Parser.parseMaybeAssign (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10348:21)\\n    at Parser.parseMaybeAssign (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10374:25)\\n    at Parser.parseExpressionBase (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10302:23)\\n    at C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10298:39\\n    at Parser.allowInAnd (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:11928:16)\\n    at Parser.parseExpression (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:10298:17)\\n    at Parser.parseStatementContent (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12372:23)\\n    at Parser.parseStatementLike (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12239:17)\\n    at Parser.parseStatementListItem (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12219:17)\\n    at Parser.parseBlockOrModuleBlockBody (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12792:61)\\n    at Parser.parseBlockBody (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12785:10)\\n    at Parser.parseBlock (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12773:10)\\n    at Parser.parseStatementContent (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12329:21)\\n    at Parser.parseStatementLike (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12239:17)\\n    at Parser.parseStatementOrSloppyAnnexBFunctionDeclaration (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12229:17)\\n    at Parser.parseIfStatement (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12606:28)\\n    at Parser.parseStatementContent (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12268:21)\\n    at Parser.parseStatementLike (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12239:17)\\n    at Parser.parseStatementListItem (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12219:17)\\n    at Parser.parseBlockOrModuleBlockBody (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12792:61)\\n    at Parser.parseBlockBody (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12785:10)\\n    at Parser.parseBlock (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12773:10)\\n    at Parser.parseFunctionBody (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:11618:24)\\n    at Parser.parseFunctionBodyAndFinish (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:11604:10)\\n    at Parser.parseMethod (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:11562:31)\\n    at Parser.pushClassMethod (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13198:30)\\n    at Parser.parseClassMemberWithIsStatic (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13086:12)\\n    at Parser.parseClassMember (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:13035:10)\\n    at C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12989:14\\n    at Parser.withSmartMixTopicForbiddingContext (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:11910:14)\\n    at Parser.parseClassBody (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12971:10)\\n    at Parser.parseClass (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12946:22)\\n    at Parser.parseStatementContent (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12266:21)\\n    at Parser.parseStatementLike (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12239:17)\\n    at Parser.parseModuleItem (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12216:17)\\n    at Parser.parseBlockOrModuleBlockBody (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12792:36)\\n    at Parser.parseBlockBody (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12785:10)\\n    at Parser.parseProgram (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12113:10)\\n    at Parser.parseTopLevel (C:\\\\dev\\\\dft\\\\node_modules\\\\@babel\\\\parser\\\\lib\\\\index.js:12103:25)\");\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/View.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.js */ \"./src/Model.js\");\n/* harmony import */ var _Controller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Controller.js */ \"./src/Controller.js\");\n/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./View.js */ \"./src/View.js\");\n//main js file\n\n\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  var model = new _Model_js__WEBPACK_IMPORTED_MODULE_0__.Model();\n  var view = new _View_js__WEBPACK_IMPORTED_MODULE_2__.View();\n  var controller = new _Controller_js__WEBPACK_IMPORTED_MODULE_1__.Controller(view, model);\n});\n\n//# sourceURL=webpack://DFT_DCT--JS/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;